import {fromNullable, isNullish, nonNullish} from '@dfinity/utils';
import {encodeIcrcAccount} from '@icp-sdk/canisters/ledger/icrc';
import {TransferArgs} from '../constants/icrc-1.idl.constants';
import {ApproveArgs, TransferFromArgs} from '../constants/icrc-2.idl.constants';
import {MAX_CONSENT_MESSAGE_ARG_SIZE_BYTES} from '../constants/signer.builders.constants';
import type {TransferArgs as IcrcTransferArg} from '../declarations/icrc-1';
import type {
  ApproveArgs as IcrcApproveArgs,
  TransferFromArgs as IcrcTransferFromArgs
} from '../declarations/icrc-2';
import type {icrc21_consent_info} from '../declarations/icrc-21';
import type {I18n} from '../types/i18n';
import type {
  SignerBuilderFn,
  SignerBuilderParams,
  SignerBuildersResult
} from '../types/signer-builders';
import {decodeMemo} from '../utils/builders.utils';
import {formatAmount, formatDate} from '../utils/format.utils';
import {decodeIdl} from '../utils/idl.utils';

/**
 * Builds a content message for an ICRC-1 transfer by decoding the arguments for a potential call.
 * This is used as a workaround when the targeted canister does not comply with the ICRC-21 standard — i.e. it has not implemented the related endpoints.
 *
 * The implementation is similar to the Markdown generated by the ICRC ledger implementation.
 * @link https://github.com/dfinity/ic/blob/master/packages/icrc-ledger-types/src/icrc21/lib.rs#L153
 *
 * @param {Object} params - Parameters for building the consent message.
 * @param {Uint8Array} params.arg - Encoded arguments for the ICRC-1 transfer.
 * @param {Principal} params.owner - Principal ID of the sender (owner) account.
 * @param {Object} params.token - Token metadata including symbol, decimals, and fee.
 * @param {string} params.token.symbol - The symbol of the token.
 * @param {number} params.token.decimals - The number of decimals for the token.
 * @param {bigint} params.token.fee - Default fee for the token.
 * @returns {Promise<SignerBuildersResult>} - A result containing either the consent message or an error.
 *
 **/
export const buildContentMessageIcrc1Transfer: SignerBuilderFn = async ({
  arg,
  owner,
  token: {symbol: tokenSymbol, decimals: tokenDecimals, fee: tokenFee}
}): Promise<SignerBuildersResult> => {
  const build = (en: I18n): {message: string[]} => {
    const {
      amount,
      from_subaccount: fromSubaccount,
      to: {owner: toOwner, subaccount: toSubaccount},
      fee,
      memo
    } = decodeIdl<IcrcTransferArg>({
      recordClass: TransferArgs,
      bytes: new Uint8Array(arg)
    });

    const {
      core: {amount: amountLabel, from, to, fee: feeLabel},
      icrc1_transfer: {title}
    } = en;

    // Title
    const message = [`# ${title}`];

    // - Amount
    message.push(
      `${section(amountLabel)}\n${formatAmount({amount, decimals: tokenDecimals})} ${tokenSymbol}`
    );

    // - From
    const fromNullishSubaccount = fromNullable(fromSubaccount);
    const fromAccount = encodeIcrcAccount({
      owner,
      subaccount: fromNullishSubaccount
    });
    message.push(`${section(from)}\n${fromAccount}`);

    // - To
    const toAccount = encodeIcrcAccount({
      owner: toOwner,
      subaccount: fromNullable(toSubaccount)
    });
    message.push(`${section(to)}\n${toAccount}`);

    // - Fee
    message.push(
      `${section(feeLabel)}\n${formatAmount({amount: fromNullable(fee) ?? tokenFee, decimals: tokenDecimals})} ${tokenSymbol}`
    );

    // - Memo
    const memoMessage = buildMemo({
      memo,
      en
    });

    return {message: [...message, ...memoMessage]};
  };

  return await buildContentMessage({arg, fn: build});
};

/**
 * Builds a content message for an ICRC-2 Approve by decoding the arguments for a potential call.
 * This is used as a workaround when the targeted canister does not comply with the ICRC-21 standard — i.e. it has not implemented the related endpoints.
 *
 * The implementation is similar to the Markdown generated by the ICRC ledger implementation.
 * @link https://github.com/dfinity/ic/blob/master/packages/icrc-ledger-types/src/icrc21/lib.rs#L194
 *
 * @param {Object} params - Parameters for building the consent message.
 * @param {Uint8Array} params.arg - Encoded arguments for the ICRC-2 approve.
 * @param {Principal} params.owner - Principal ID of the sender (owner) account.
 * @param {Object} params.token - Token metadata including symbol, decimals, and fee.
 * @param {string} params.token.symbol - The symbol of the token.
 * @param {number} params.token.decimals - The number of decimals for the token.
 * @param {bigint} params.token.fee - Default fee for the token.
 * @returns {Promise<SignerBuildersResult>} - A result containing either the consent message or an error.
 *
 **/
export const buildContentMessageIcrc2Approve: SignerBuilderFn = async ({
  arg,
  owner,
  token: {symbol: tokenSymbol, decimals: tokenDecimals, fee: tokenFee}
}): Promise<SignerBuildersResult> => {
  const build = (en: I18n): {message: string[]} => {
    const {
      spender: {owner: spenderOwner, subaccount: spenderSubaccount},
      from_subaccount: fromSubaccount,
      amount,
      expected_allowance,
      expires_at,
      fee: approveFee,
      memo
    } = decodeIdl<IcrcApproveArgs>({
      recordClass: ApproveArgs,
      bytes: new Uint8Array(arg)
    });

    const {
      icrc2_approve: {
        title,
        address_is_allowed,
        your_account,
        requested_withdrawal_allowance,
        withdrawal_allowance: {none: withdrawalAllowanceNone, some: withdrawalAllowanceSome},
        expiration_date: {title: expirationDateTitle, none: noExpirationDate},
        approval_fee: approvalFeeLabel,
        approver_account_transaction_fees
      }
    } = en;

    // Title
    const message = [`# ${title}`];

    // - Spender
    const spenderAccount = encodeIcrcAccount({
      owner: spenderOwner,
      subaccount: fromNullable(spenderSubaccount)
    });
    message.push(`${section(address_is_allowed)}\n${spenderAccount}`);

    // - Approver
    const fromNullishSubaccount = fromNullable(fromSubaccount);
    const fromAccount = encodeIcrcAccount({
      owner,
      subaccount: fromNullishSubaccount
    });
    message.push(`${section(your_account)}\n${fromAccount}`);

    // - Amount
    message.push(
      `${section(requested_withdrawal_allowance)}\n${formatAmount({amount, decimals: tokenDecimals})} ${tokenSymbol}`
    );

    // - Expected allowance
    const expectedAllowance = fromNullable(expected_allowance);
    if (nonNullish(expectedAllowance)) {
      message.push(
        `${section(withdrawalAllowanceSome)}\n${formatAmount({amount: expectedAllowance, decimals: tokenDecimals})} ${tokenSymbol}`
      );
    } else {
      message.push(
        `⚠ ${withdrawalAllowanceNone
          .replace('{amount}', formatAmount({amount, decimals: tokenDecimals}))
          .replace('{symbol}', tokenSymbol)}`
      );
    }

    // - Expires at
    const expiresAt = fromNullable(expires_at);
    message.push(
      `${section(expirationDateTitle)}\n${nonNullish(expiresAt) ? formatDate(expiresAt) : noExpirationDate}`
    );

    // - Fee
    message.push(
      `${section(approvalFeeLabel)}\n${formatAmount({amount: fromNullable(approveFee) ?? tokenFee, decimals: tokenDecimals})} ${tokenSymbol}`
    );

    // - Fee paid by
    message.push(`${section(approver_account_transaction_fees)}\n${fromAccount}`);

    // - Memo
    const memoMessage = buildMemo({
      memo,
      en
    });

    return {message: [...message, ...memoMessage]};
  };

  return await buildContentMessage({arg, fn: build});
};

/**
 * Builds a content message for an ICRC-2 TransferFrom by decoding the arguments for a potential call.
 * This is used as a workaround when the targeted canister does not comply with the ICRC-21 standard — i.e. it has not implemented the related endpoints.
 *
 * The implementation is similar to the Markdown generated by the ICRC ledger implementation.
 * @link https://github.com/dfinity/ic/blob/master/packages/icrc-ledger-types/src/icrc21/lib.rs#L287
 *
 * @param {Object} params - Parameters for building the consent message.
 * @param {Uint8Array} params.arg - Encoded arguments for the ICRC-2 transfer from.
 * @param {Principal} params.owner - Principal ID of the sender (owner) account.
 * @param {Object} params.token - Token metadata including symbol, decimals, and fee.
 * @param {string} params.token.symbol - The symbol of the token.
 * @param {number} params.token.decimals - The number of decimals for the token.
 * @param {bigint} params.token.fee - Default fee for the token.
 * @returns {Promise<SignerBuildersResult>} - A result containing either the consent message or an error.
 *
 **/
export const buildContentMessageIcrc2TransferFrom: SignerBuilderFn = async ({
  arg,
  owner,
  token: {symbol: tokenSymbol, decimals: tokenDecimals, fee: tokenFee}
}): Promise<SignerBuildersResult> => {
  const build = (en: I18n): {message: string[]} => {
    const {
      from: {owner: fromOwner, subaccount: fromSubaccount},
      to: {owner: toOwner, subaccount: toSubaccount},
      spender_subaccount: spenderSubaccount,
      amount,
      fee,
      memo
    } = decodeIdl<IcrcTransferFromArgs>({
      recordClass: TransferFromArgs,
      bytes: new Uint8Array(arg)
    });

    const {
      core: {to},
      icrc2_transfer_from: {
        title,
        withdrawal_account,
        sending_the_transfer_request,
        amount_to_withdraw,
        fee_paid_by_withdrawal_account
      }
    } = en;

    // Title
    const message = [`# ${title}`];

    // - From
    const fromAccount = encodeIcrcAccount({
      owner: fromOwner,
      subaccount: fromNullable(fromSubaccount)
    });
    message.push(`${section(withdrawal_account)}\n${fromAccount}`);

    // - Spender
    const spenderNullishSubaccount = fromNullable(spenderSubaccount);
    const spenderAccount = encodeIcrcAccount({
      owner,
      subaccount: spenderNullishSubaccount
    });
    message.push(`${section(sending_the_transfer_request)}\n${spenderAccount}`);

    // - Amount
    message.push(
      `${section(amount_to_withdraw)}\n${formatAmount({amount, decimals: tokenDecimals})} ${tokenSymbol}`
    );

    // - To
    const toAccount = encodeIcrcAccount({
      owner: toOwner,
      subaccount: fromNullable(toSubaccount)
    });
    message.push(`${section(to)}\n${toAccount}`);

    // - Fee paid by
    message.push(
      `${section(fee_paid_by_withdrawal_account)}\n${formatAmount({amount: fromNullable(fee) ?? tokenFee, decimals: tokenDecimals})} ${tokenSymbol}`
    );

    // - Memo
    const memoMessage = buildMemo({
      memo,
      en
    });

    return {message: [...message, ...memoMessage]};
  };

  return await buildContentMessage({arg, fn: build});
};

const section = (text: string): string => `**${text}:**`;

const buildMemo = ({memo, en}: {memo: [] | [Uint8Array | number[]]; en: I18n}): [] | [string] => {
  const nullishMemo = fromNullable(memo);

  if (isNullish(nullishMemo)) {
    return [];
  }

  const {
    core: {memo: memoLabel}
  } = en;

  return [`${section(memoLabel)}\n${decodeMemo(nullishMemo)}`];
};

const buildContentMessage = async ({
  fn,
  arg
}: Pick<SignerBuilderParams, 'arg'> & {
  fn: (en: I18n) => {message: string[]};
}): Promise<SignerBuildersResult> => {
  try {
    assertArgSize({arg});

    // TODO: support i18n
    // eslint-disable-next-line import/no-relative-parent-imports
    const {default: en} = await import('../i18n/en.json');

    const {message} = fn(en);

    const consentMessage: icrc21_consent_info = {
      metadata: {
        language: 'en',
        utc_offset_minutes: []
      },
      consent_message: {
        GenericDisplayMessage: message.join('\n\n')
      }
    };

    return {Ok: consentMessage};
  } catch (err: unknown) {
    return {Err: err};
  }
};

export class ArgSizeError extends Error {}

/**
 * Validates the size of the argument to prevent issues with the Candid parser.
 *
 * A similar assertion is implemented in the ICP ledger for building the consent message.
 *
 * @see {@link https://github.com/dfinity/ic/blob/master/packages/icrc-ledger-types/src/icrc21/lib.rs#L426}
 *
 * @param {object} params - The parameters for the function.
 * @param {ArrayBuffer} params.arg - The argument to validate, represented as an ArrayBuffer.
 * @throws {Error} Throws an error if the argument size exceeds the maximum allowed size.
 */
const assertArgSize = ({arg}: Pick<SignerBuilderParams, 'arg'>) => {
  if (arg.byteLength > MAX_CONSENT_MESSAGE_ARG_SIZE_BYTES) {
    throw new ArgSizeError(
      `The argument size is too large. The maximum allowed size is ${MAX_CONSENT_MESSAGE_ARG_SIZE_BYTES} bytes.`
    );
  }
};
